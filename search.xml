<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[RequireJS 配置]]></title>
      <url>%2F2016%2F12%2F30%2FRequireJSDoc%2F</url>
      <content type="text"><![CDATA[加载JavaScript文件RequireJS使用了不同于传统&lt;script&gt;标签加载脚本的方法。然后它也可以运行得很快，优化好，主要目的是为了鼓励JavaScript代码模块化。除此之外，它还鼓励使用module IDs取代script标签的URLs路径。 RequierJS相对于baseUrl指定的路径来加载所有代码。data-main属性指定了加载页面的最顶部脚本，baseUrl通常设置为与data-main指定脚本的所在目录相同。require.js会检查data-main属性开始加载脚本。 baseUrl可以在RequireJS config文件中手动配置，如果没有显示配置该属性并且没有使用data-main属性，那么默认的baseUrl是运行RequireJS的HTML页面所在的目录。 RequireJS同样假定默认所有依赖模块都是js脚本，因此不需要在module IDs加”.js”后缀。RequireJS在转换module ID为路径时会自动添加后缀。可以在paths config中指定一组脚本的位置。 很多时候，你想直接引入一个脚本文件，并且不习惯通过”baseUrl+paths”规则找到它。RequireJS也会有相应的处理。如果一个module ID有以下字符，那么这个ID不会通过”baseUrl+paths”配置的方式传入，而是把它当成相对于当前页面所在的URL（与页面中直接指定一样）。 以”.js”结尾 以”/“开头 包含”http:”或者”https” URL协议 data-main 入口点require.js将会检查data-main这个特殊的属性值并开始脚本加载。 通常会使用data-main脚本设置配置选项，然后加载第一个应用程序模块。需要注意:require.js为data-main模块生成的script标签会包含async属性。这意味着你不能假定data-main脚本的加载和执行将会优先在页面后面引用的其他脚本之前完成。 下面的例子中，不能保证require.config中’foo’模块在other.js运行之前加载完成，所以在后面的other.js中通过require()加载foo模块，会尝试加载script/foo.js文件，而不是我们指定的文件。 12&lt;script data-main=&quot;scripts/main&quot; src=&quot;scripts/require.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;scripts/other.js&quot;&gt;&lt;/script&gt; 123456// contents of main.js:require.config(&#123; paths: &#123; foo: &apos;libs/foo-1.1.3&apos; &#125;&#125;); 12345678// contents of other.js:// This code might be called before the require.config() in main.js// has executed. When that happens, require.js will attempt to// load &apos;scripts/foo.js&apos; instead of &apos;scripts/libs/foo-1.1.3.js&apos;require([&apos;foo&apos;], function(foo) &#123;&#125;); 如果想要在HTML页面调用require()方法，最好不要使用data-main属性。data-main属性仅供那些只有一个主入口点(data-main脚本)的页面使用。对于想要内联调用require()的页面，最好把该调用包含在require()调用configuration的回调函数中。12345678910&lt;script src=&quot;scripts/require.js&quot;&gt;&lt;/script&gt;&lt;script&gt; require([&apos;scripts/config&apos;], function() &#123; // Configuration loaded now, safe to do other require calls // that depend on that config. require([&apos;foo&apos;], function(foo) &#123; &#125;); &#125;);&lt;/script&gt; 定义一个模块一个模块与传统的脚本文件的不同在于，模块定义了一个封闭的作用域对象避免了污染全局命令空间。它可以显示的列出它所有的依赖，并且能够很好的处理这些依赖而无需引用全局对象，而不是通过接受这些依赖为函数的参数来定义这个模块。RequireJS中的模块是Module Pattern的扩展，好处是不需要通过引入全局对象来引用其他模块。 RequireJS语法可以使模块尽可能地快速加载，即便次序颠倒，它也能估算出正确的依赖顺序，因为没有引入全局变量，所以它可以在一个页面上加载一个模块的多个版本。 简单键/值对如果该模块没有任何依赖，只是一个键值对集合，那么只需要把字面量对象作为参数传入define()函数。 12345//Inside file my/shirt.js:define(&#123; color: &quot;black&quot;, size: &quot;unisize&quot;&#125;); 定义函数如果模块没有任何依赖，但是需要使用函数来做一些初始设置，把一个函数作为参数传入给define()函数。123456789//my/shirt.js now does setup work//before returning its module definition.define(function () &#123; //Do setup work here return &#123; color: &quot;black&quot;, size: &quot;unisize&quot; &#125;&#125;); 定义有模块依赖的函数如果该模块有依赖，那么define()函数的第一个参数应该是一个包含依赖模块名的数组，第二个参数应该是一个定义函数，一旦所有的依赖模块都加载后，会调用该函数来定义该模块。依赖会作为函数参数传入定义函数，参数顺序与依赖模块数组一致。1234567891011121314//my/shirt.js now has some dependencies, a cart and inventory//module in the same directory as shirt.jsdefine([&quot;./cart&quot;, &quot;./inventory&quot;], function(cart, inventory) &#123; //return an object to define the &quot;my/shirt&quot; module. return &#123; color: &quot;blue&quot;, size: &quot;large&quot;, addToCart: function() &#123; inventory.decrement(this); cart.add(this); &#125; &#125; &#125;); 在上面这个例子中，创建了一个my/shirt模块。它依赖于my/cart和my/inventory。在硬盘上的结构如下： - `my/cart.js` - `my/inventory.js` - `my/shirt.js` 上面的函数调用指定了两个参数，cart和inventory。这对应着&quot;./cart&quot;和&quot;./inventory&quot;模块的模块名。上面的在my/cart和my/inventory模块被加载之后才调用。返回的对象定义了my/shirt模块。通过这种方式定义的模块，不会以全局对象形式存在。 定义函数作为一个模块模块不返回对象。任意合法的函数返回值都是可以的。下面的例子中，返回了一个函数作为模块定义。1234567891011121314151617//A module definition inside foo/title.js. It uses//my/cart and my/inventory modules from before,//but since foo/title.js is in a different directory than//the &quot;my&quot; modules, it uses the &quot;my&quot; in the module dependency//name to find them. The &quot;my&quot; part of the name can be mapped//to any directory, but by default, it is assumed to be a//sibling to the &quot;foo&quot; directory.define([&quot;my/cart&quot;, &quot;my/inventory&quot;], function(cart, inventory) &#123; //return a function to define &quot;foo/title&quot;. //It gets or sets the window title. return function(title) &#123; return title ? (window.title = title) : inventory.storeName + &apos; &apos; + cart.name; &#125; &#125;); 定义一个简化的CommonJS包装模块如果你想重用那些用CommonJS模块格式写的代码，通过重做上面代码中依赖数组模块会很困难，你可能喜欢直接通过依赖名字取到模块作为本地变量来使用依赖模块。在这种情况下，你可以使用简单的CommonJS包装：1234567define(function(require, exports, module) &#123; var a = require(&apos;a&apos;), b = require(&apos;b&apos;); //Return the module value return function () &#123;&#125;; &#125;); 这个包装器依赖于Function.prototype.toString(),以字符串的形式返回了函数的内容。 定义一个命名模块你也许会碰到有些情况下,调用define()包含一个该模块的名字作为define()函数的第一个参数。1234567//Explicitly defines the &quot;foo/title&quot; module:define(&quot;foo/title&quot;, [&quot;my/cart&quot;, &quot;my/inventory&quot;], function(cart, inventory) &#123; //Define foo/title object in here. &#125;); 你可以显示提供模块名，但是会使模块可移植性低。如果你把该文件移动到其他文件夹，你就需要改变模块名。通常最好避免在代码中指定模块名，optimization tool会自动为模块命名，这样可以通过模块名将多个模块打包到一个文件中，从而在浏览器中更快的加载。 其他模块说明一个模块一个文件：每一个JavaScript文件只定义一个模块，使得模块易于通过name-to-file-path算法来查找，使用optimization tool组织多模块到优化文件中。define()里使用相对模块名:如果在define()调用的回调函数中调用require(&quot;./relative/name&quot;),需要先添加require为依赖，以便于正确解析模块的相对路径。 123define([&quot;require&quot;, &quot;./relative/name&quot;], function(require) &#123; var mod = require(&quot;./relative/name&quot;);&#125;); 或者使用转换CommonJS模块的快捷语法更好。 123define(function(require) &#123; var mod = require(&quot;./relative/name&quot;);&#125;); 这种形式使用Function.prototype.toString()查找函数内部的require()调用，并且将它们与require模块一起添加到依赖数组中。 如果你正在一个目录中创建几个模块时，相对路径是非常有用的，这样你就可以与其他人或者项目共享该目录，并且你可以在不需要知道目录名的情况下，得到模块所在目录的兄弟模块。 相对模块名是相对于其他名字，而不是路径:加载器内部使用模块名字而不是模块路径来存储模块。因此对于相对名字引用，都是解析为相对于模块名的引用，然后在需要加载的时候才把模块名或者ID转换成模块路径。示例代码中，compute包 含有main和extras两个模块： 1234* lib/ * compute/ * main.js * extras.js main.js: 123define([&quot;./extras&quot;], function(extras) &#123; //Uses extras in here.&#125;); 如果有paths配置如下: 123456require.config(&#123; baseUrl: &apos;lib&apos;, paths: &#123; &apos;compute&apos;: &apos;compute/main&apos; &#125;&#125;); require([&#39;compute&#39;])完成时，lib/compute/main.js会以&#39;compute&#39;为模块名。当请求&#39;./extras.js&#39;时，是相对于&#39;compute&#39;解析的，为&#39;compute/./extras&#39;，规范化为&#39;extras&#39;。因为paths配置中并没有指定该模块,生成的路径将会是&#39;lib\extra.js&#39;，是不对的。 这种情况，package config是一个好的选择。由于它允许将main模块设为&#39;compute&#39;,但是在加载器内部，会用&#39;compute/main&#39;这个ID存储该模块，因此&#39;./extras&#39;的相对引用会生效。 另一个选择是在构建一个模块lib/compute.js,不需要paths或者package做配置。 1define([&apos;./compute/main&apos;], function(m) &#123; return m; &#125;); 或者不设置paths或者packages,在最顶部调用require([&#39;compute/main&#39;])。 生成相对于模块的URLs:你也许需要生成一个相对于模块路径的URL。只需要添加&quot;require&quot;模块为依赖，然后调用require.toUrl()来生成URL。 123define([&quot;require&quot;], function(require) &#123; var cssUrl = require.toUrl(&quot;./style.css&quot;);&#125;); 控制台调试:如果你需要用到已经通过在JavaScript控制台调用require([&quot;module/name&quot;]，function(){})加载的模块，那么你只需要用到模块名字符串以require()形式获取它。 1require(&quot;module/name&quot;).callSomeFunction() 注意只有在&quot;module/namae&quot;之前是通过异步版本的require:require([&quot;module/name&quot;])加载时才生效。如果使用相对路径，类似./module/name，只有在define内部才可用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的类型转换]]></title>
      <url>%2F2016%2F12%2F30%2FJavaScript-Type%2F</url>
      <content type="text"><![CDATA[JavaScrip中的数据类型分为两类：原始类型(primitive type)和对象类型(object type)。 原始类型包括数字(number),字符串(string),布尔值(boolean),null,undefined。对象类型包括普通对象和内置对象(包装对象String,Number,Boolean;Array,Function,Date,RegExp,全局对象Math,JSON)。 原始值到原始值的转换 undefined,null,0,-0,NaN,””转换为布尔值结果为false,称为falsy value.所有其他值，包括对象都会被转换为true,称为truthy value。 true转换为number时，结果为1,false和空字符串””转换为number时，结果为0。 数字表示的字符串可以直接转换为数字，也允许在开始和结尾处带有空格，但是开始和结尾处的任意非空字符都不被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN。 原始值到对象的转换 null和undefined在期望是一个对象的地方都会造成一个类型错误(TypeError)异常，而不会执行正常的转换。 通过调用String(),Number(),Boolean()构造函数转换为它们各自的包装对象。 对象到原始值的转换所有的对象都继承了两个转换方法: toString(),它返回一个反应这个对象的字符串。 valueOf(),如果存在任意原始值，它默认将对象转换为表示它的原始值。对象时复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单的返回对象本身，而不是返回一个原始值。特例：Date类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日以来的毫秒数。 对象到字符串转换过程 如果对象具有toString()方法，则调用这个方法。如果它返回一个原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。 如果对象没有toString()方法，或者这个方法并不返回一个原始值,JavaScript会调用valueOf()方法。如果存在这个方法,JavaScript就会调用它，如果返回结果是原始值,JavaScript将这个值转换为字符串（如果不是字符串），并返回这个字符串结果。 否则，JavaScript无法从toString()或valueOf()获取一个原始值，因此它将抛出一个TypeError异常。 对象到数字转换过程 如果对象具有valueOf()方法，返回一个原始值，则JavaScript将这个原始值转换为数字(如果需要的话)并返回这个数字。 否则，如果对象具有toString()方法，返回一个原始值（字符串直接量），则JavaScript将其转换为数字类型并返回。 否则，JavaScript抛出一个TypeError异常。 “+”和”==”运算符应用到对象到原始值的转换时,如果是日期对象，则先调用toString()方法；如果是其他对象，则先调用valueOf()方法，只要返回了原始值就会直接使用，不会被强制转换为数字或字符串。 “&lt;”,”!=”等关系运算符应用到对象到原始值的转换时，任何对象都会首先尝试调用valueOf()，然后调用toString()。不管得到的原始值是否直接使用，它都不会进一步被转换成数字或字符串。 “-“运算符把它的两个操作数都转换为数字。 示例: 1[]+&#123;&#125; //返回&quot;[object Object]&quot; []调用valueOf()方法返回[]本身，不是原始值，调用toString()返回””,{}调用valueOf()方法返回{}本身，不是原始值，调用toString()返回”[object Object]” 1&#123;&#125;+[] //返回0 {}被JavaScript引擎解析为语句块，因此表达式相当于+[],将[]操作数转换为数字，先调用valueOf()方法返回自身，不是原始值，再调用toString()方法，返回””，是原始值，转换为数字类型为0。 1(&#123;&#125;+[]) //返回&quot;[object Object]&quot; 11+[] //返回&quot;1&quot; 先调用valueOf()方法返回自身，不是原始值，再调用toString()方法，返回””，是原始值，不会被强制转换为数字，而是直接使用””,所以结果为”1” 11&lt;new Date() //返回true 先调用valueOf()返回自1970年1月1日以来的毫秒数，为原始值，直接使用，比1大，所以为true.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F28%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
